/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "distrust_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace distrust {


ModelInfo::~ModelInfo() throw() {
}


void ModelInfo::__set_window_size(const int32_t val) {
  this->window_size = val;
}

void ModelInfo::__set_wordvec_dim(const int32_t val) {
  this->wordvec_dim = val;
}

void ModelInfo::__set_hidden_dim(const int32_t val) {
  this->hidden_dim = val;
}

void ModelInfo::__set_start_token_index(const int32_t val) {
  this->start_token_index = val;
}

void ModelInfo::__set_end_token_index(const int32_t val) {
  this->end_token_index = val;
}

void ModelInfo::__set_unk_token_index(const int32_t val) {
  this->unk_token_index = val;
}

void ModelInfo::__set_vocab(const std::vector<std::string> & val) {
  this->vocab = val;
}

const char* ModelInfo::ascii_fingerprint = "DB2CF0470155E4641638FF4CB4C715EE";
const uint8_t ModelInfo::binary_fingerprint[16] = {0xDB,0x2C,0xF0,0x47,0x01,0x55,0xE4,0x64,0x16,0x38,0xFF,0x4C,0xB4,0xC7,0x15,0xEE};

uint32_t ModelInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->window_size);
          this->__isset.window_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->wordvec_dim);
          this->__isset.wordvec_dim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hidden_dim);
          this->__isset.hidden_dim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start_token_index);
          this->__isset.start_token_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->end_token_index);
          this->__isset.end_token_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->unk_token_index);
          this->__isset.unk_token_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vocab.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->vocab.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readString(this->vocab[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vocab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModelInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ModelInfo");

  xfer += oprot->writeFieldBegin("window_size", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->window_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wordvec_dim", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->wordvec_dim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hidden_dim", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->hidden_dim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_token_index", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->start_token_index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_token_index", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->end_token_index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unk_token_index", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->unk_token_index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vocab", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->vocab.size()));
    std::vector<std::string> ::const_iterator _iter5;
    for (_iter5 = this->vocab.begin(); _iter5 != this->vocab.end(); ++_iter5)
    {
      xfer += oprot->writeString((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ModelInfo &a, ModelInfo &b) {
  using ::std::swap;
  swap(a.window_size, b.window_size);
  swap(a.wordvec_dim, b.wordvec_dim);
  swap(a.hidden_dim, b.hidden_dim);
  swap(a.start_token_index, b.start_token_index);
  swap(a.end_token_index, b.end_token_index);
  swap(a.unk_token_index, b.unk_token_index);
  swap(a.vocab, b.vocab);
  swap(a.__isset, b.__isset);
}

ModelInfo::ModelInfo(const ModelInfo& other6) {
  window_size = other6.window_size;
  wordvec_dim = other6.wordvec_dim;
  hidden_dim = other6.hidden_dim;
  start_token_index = other6.start_token_index;
  end_token_index = other6.end_token_index;
  unk_token_index = other6.unk_token_index;
  vocab = other6.vocab;
  __isset = other6.__isset;
}
ModelInfo& ModelInfo::operator=(const ModelInfo& other7) {
  window_size = other7.window_size;
  wordvec_dim = other7.wordvec_dim;
  hidden_dim = other7.hidden_dim;
  start_token_index = other7.start_token_index;
  end_token_index = other7.end_token_index;
  unk_token_index = other7.unk_token_index;
  vocab = other7.vocab;
  __isset = other7.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ModelInfo& obj) {
  using apache::thrift::to_string;
  out << "ModelInfo(";
  out << "window_size=" << to_string(obj.window_size);
  out << ", " << "wordvec_dim=" << to_string(obj.wordvec_dim);
  out << ", " << "hidden_dim=" << to_string(obj.hidden_dim);
  out << ", " << "start_token_index=" << to_string(obj.start_token_index);
  out << ", " << "end_token_index=" << to_string(obj.end_token_index);
  out << ", " << "unk_token_index=" << to_string(obj.unk_token_index);
  out << ", " << "vocab=" << to_string(obj.vocab);
  out << ")";
  return out;
}


Params::~Params() throw() {
}


void Params::__set_wordvec_weights(const std::vector<double> & val) {
  this->wordvec_weights = val;
}

void Params::__set_input_hidden_weights(const std::vector<double> & val) {
  this->input_hidden_weights = val;
}

void Params::__set_input_hidden_biases(const std::vector<double> & val) {
  this->input_hidden_biases = val;
}

void Params::__set_hidden_output_weights(const std::vector<double> & val) {
  this->hidden_output_weights = val;
}

void Params::__set_hidden_output_biases(const std::vector<double> & val) {
  this->hidden_output_biases = val;
}

const char* Params::ascii_fingerprint = "882E5A0F5FB0D66D6CADC597860F19AF";
const uint8_t Params::binary_fingerprint[16] = {0x88,0x2E,0x5A,0x0F,0x5F,0xB0,0xD6,0x6D,0x6C,0xAD,0xC5,0x97,0x86,0x0F,0x19,0xAF};

uint32_t Params::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->wordvec_weights.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->wordvec_weights.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += iprot->readDouble(this->wordvec_weights[_i12]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.wordvec_weights = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->input_hidden_weights.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->input_hidden_weights.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += iprot->readDouble(this->input_hidden_weights[_i17]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.input_hidden_weights = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->input_hidden_biases.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->input_hidden_biases.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += iprot->readDouble(this->input_hidden_biases[_i22]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.input_hidden_biases = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hidden_output_weights.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->hidden_output_weights.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += iprot->readDouble(this->hidden_output_weights[_i27]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hidden_output_weights = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hidden_output_biases.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->hidden_output_biases.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += iprot->readDouble(this->hidden_output_biases[_i32]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hidden_output_biases = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Params::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Params");

  xfer += oprot->writeFieldBegin("wordvec_weights", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->wordvec_weights.size()));
    std::vector<double> ::const_iterator _iter33;
    for (_iter33 = this->wordvec_weights.begin(); _iter33 != this->wordvec_weights.end(); ++_iter33)
    {
      xfer += oprot->writeDouble((*_iter33));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("input_hidden_weights", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->input_hidden_weights.size()));
    std::vector<double> ::const_iterator _iter34;
    for (_iter34 = this->input_hidden_weights.begin(); _iter34 != this->input_hidden_weights.end(); ++_iter34)
    {
      xfer += oprot->writeDouble((*_iter34));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("input_hidden_biases", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->input_hidden_biases.size()));
    std::vector<double> ::const_iterator _iter35;
    for (_iter35 = this->input_hidden_biases.begin(); _iter35 != this->input_hidden_biases.end(); ++_iter35)
    {
      xfer += oprot->writeDouble((*_iter35));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hidden_output_weights", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->hidden_output_weights.size()));
    std::vector<double> ::const_iterator _iter36;
    for (_iter36 = this->hidden_output_weights.begin(); _iter36 != this->hidden_output_weights.end(); ++_iter36)
    {
      xfer += oprot->writeDouble((*_iter36));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hidden_output_biases", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->hidden_output_biases.size()));
    std::vector<double> ::const_iterator _iter37;
    for (_iter37 = this->hidden_output_biases.begin(); _iter37 != this->hidden_output_biases.end(); ++_iter37)
    {
      xfer += oprot->writeDouble((*_iter37));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Params &a, Params &b) {
  using ::std::swap;
  swap(a.wordvec_weights, b.wordvec_weights);
  swap(a.input_hidden_weights, b.input_hidden_weights);
  swap(a.input_hidden_biases, b.input_hidden_biases);
  swap(a.hidden_output_weights, b.hidden_output_weights);
  swap(a.hidden_output_biases, b.hidden_output_biases);
  swap(a.__isset, b.__isset);
}

Params::Params(const Params& other38) {
  wordvec_weights = other38.wordvec_weights;
  input_hidden_weights = other38.input_hidden_weights;
  input_hidden_biases = other38.input_hidden_biases;
  hidden_output_weights = other38.hidden_output_weights;
  hidden_output_biases = other38.hidden_output_biases;
  __isset = other38.__isset;
}
Params& Params::operator=(const Params& other39) {
  wordvec_weights = other39.wordvec_weights;
  input_hidden_weights = other39.input_hidden_weights;
  input_hidden_biases = other39.input_hidden_biases;
  hidden_output_weights = other39.hidden_output_weights;
  hidden_output_biases = other39.hidden_output_biases;
  __isset = other39.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Params& obj) {
  using apache::thrift::to_string;
  out << "Params(";
  out << "wordvec_weights=" << to_string(obj.wordvec_weights);
  out << ", " << "input_hidden_weights=" << to_string(obj.input_hidden_weights);
  out << ", " << "input_hidden_biases=" << to_string(obj.input_hidden_biases);
  out << ", " << "hidden_output_weights=" << to_string(obj.hidden_output_weights);
  out << ", " << "hidden_output_biases=" << to_string(obj.hidden_output_biases);
  out << ")";
  return out;
}


AnnounceResponse::~AnnounceResponse() throw() {
}


void AnnounceResponse::__set_model_info(const ModelInfo& val) {
  this->model_info = val;
}

void AnnounceResponse::__set_params(const Params& val) {
  this->params = val;
}

void AnnounceResponse::__set_shard_paths(const std::vector<std::string> & val) {
  this->shard_paths = val;
}

void AnnounceResponse::__set_learn_rate(const double val) {
  this->learn_rate = val;
}

const char* AnnounceResponse::ascii_fingerprint = "370814B177BFFA9DA1F1788F8C73699F";
const uint8_t AnnounceResponse::binary_fingerprint[16] = {0x37,0x08,0x14,0xB1,0x77,0xBF,0xFA,0x9D,0xA1,0xF1,0x78,0x8F,0x8C,0x73,0x69,0x9F};

uint32_t AnnounceResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->model_info.read(iprot);
          this->__isset.model_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->shard_paths.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readListBegin(_etype43, _size40);
            this->shard_paths.resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += iprot->readString(this->shard_paths[_i44]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.shard_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->learn_rate);
          this->__isset.learn_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AnnounceResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("AnnounceResponse");

  xfer += oprot->writeFieldBegin("model_info", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->model_info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shard_paths", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->shard_paths.size()));
    std::vector<std::string> ::const_iterator _iter45;
    for (_iter45 = this->shard_paths.begin(); _iter45 != this->shard_paths.end(); ++_iter45)
    {
      xfer += oprot->writeString((*_iter45));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("learn_rate", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->learn_rate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(AnnounceResponse &a, AnnounceResponse &b) {
  using ::std::swap;
  swap(a.model_info, b.model_info);
  swap(a.params, b.params);
  swap(a.shard_paths, b.shard_paths);
  swap(a.learn_rate, b.learn_rate);
  swap(a.__isset, b.__isset);
}

AnnounceResponse::AnnounceResponse(const AnnounceResponse& other46) {
  model_info = other46.model_info;
  params = other46.params;
  shard_paths = other46.shard_paths;
  learn_rate = other46.learn_rate;
  __isset = other46.__isset;
}
AnnounceResponse& AnnounceResponse::operator=(const AnnounceResponse& other47) {
  model_info = other47.model_info;
  params = other47.params;
  shard_paths = other47.shard_paths;
  learn_rate = other47.learn_rate;
  __isset = other47.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const AnnounceResponse& obj) {
  using apache::thrift::to_string;
  out << "AnnounceResponse(";
  out << "model_info=" << to_string(obj.model_info);
  out << ", " << "params=" << to_string(obj.params);
  out << ", " << "shard_paths=" << to_string(obj.shard_paths);
  out << ", " << "learn_rate=" << to_string(obj.learn_rate);
  out << ")";
  return out;
}


HBResponse::~HBResponse() throw() {
}


void HBResponse::__set_completed_shards(const std::vector<std::string> & val) {
  this->completed_shards = val;
}

const char* HBResponse::ascii_fingerprint = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
const uint8_t HBResponse::binary_fingerprint[16] = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

uint32_t HBResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->completed_shards.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->completed_shards.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readString(this->completed_shards[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.completed_shards = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HBResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("HBResponse");

  xfer += oprot->writeFieldBegin("completed_shards", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->completed_shards.size()));
    std::vector<std::string> ::const_iterator _iter53;
    for (_iter53 = this->completed_shards.begin(); _iter53 != this->completed_shards.end(); ++_iter53)
    {
      xfer += oprot->writeString((*_iter53));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(HBResponse &a, HBResponse &b) {
  using ::std::swap;
  swap(a.completed_shards, b.completed_shards);
  swap(a.__isset, b.__isset);
}

HBResponse::HBResponse(const HBResponse& other54) {
  completed_shards = other54.completed_shards;
  __isset = other54.__isset;
}
HBResponse& HBResponse::operator=(const HBResponse& other55) {
  completed_shards = other55.completed_shards;
  __isset = other55.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const HBResponse& obj) {
  using apache::thrift::to_string;
  out << "HBResponse(";
  out << "completed_shards=" << to_string(obj.completed_shards);
  out << ")";
  return out;
}


StartRequest::~StartRequest() throw() {
}


void StartRequest::__set_shard_paths(const std::vector<std::string> & val) {
  this->shard_paths = val;
}

void StartRequest::__set_learn_rate(const double val) {
  this->learn_rate = val;
}

const char* StartRequest::ascii_fingerprint = "F96E9B21D37ECC1E6B1D9CC351B177C9";
const uint8_t StartRequest::binary_fingerprint[16] = {0xF9,0x6E,0x9B,0x21,0xD3,0x7E,0xCC,0x1E,0x6B,0x1D,0x9C,0xC3,0x51,0xB1,0x77,0xC9};

uint32_t StartRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->shard_paths.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->shard_paths.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += iprot->readString(this->shard_paths[_i60]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.shard_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->learn_rate);
          this->__isset.learn_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StartRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("StartRequest");

  xfer += oprot->writeFieldBegin("shard_paths", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->shard_paths.size()));
    std::vector<std::string> ::const_iterator _iter61;
    for (_iter61 = this->shard_paths.begin(); _iter61 != this->shard_paths.end(); ++_iter61)
    {
      xfer += oprot->writeString((*_iter61));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("learn_rate", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->learn_rate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(StartRequest &a, StartRequest &b) {
  using ::std::swap;
  swap(a.shard_paths, b.shard_paths);
  swap(a.learn_rate, b.learn_rate);
  swap(a.__isset, b.__isset);
}

StartRequest::StartRequest(const StartRequest& other62) {
  shard_paths = other62.shard_paths;
  learn_rate = other62.learn_rate;
  __isset = other62.__isset;
}
StartRequest& StartRequest::operator=(const StartRequest& other63) {
  shard_paths = other63.shard_paths;
  learn_rate = other63.learn_rate;
  __isset = other63.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const StartRequest& obj) {
  using apache::thrift::to_string;
  out << "StartRequest(";
  out << "shard_paths=" << to_string(obj.shard_paths);
  out << ", " << "learn_rate=" << to_string(obj.learn_rate);
  out << ")";
  return out;
}

} // namespace
