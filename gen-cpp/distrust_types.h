/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef distrust_TYPES_H
#define distrust_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace distrust {

typedef struct _ModelInfo__isset {
  _ModelInfo__isset() : window_size(false), wordvec_dim(false), hidden_dim(false), start_token_index(false), end_token_index(false), unk_token_index(false), vocab(false) {}
  bool window_size;
  bool wordvec_dim;
  bool hidden_dim;
  bool start_token_index;
  bool end_token_index;
  bool unk_token_index;
  bool vocab;
} _ModelInfo__isset;

class ModelInfo {
 public:

  static const char* ascii_fingerprint; // = "DB2CF0470155E4641638FF4CB4C715EE";
  static const uint8_t binary_fingerprint[16]; // = {0xDB,0x2C,0xF0,0x47,0x01,0x55,0xE4,0x64,0x16,0x38,0xFF,0x4C,0xB4,0xC7,0x15,0xEE};

  ModelInfo() : window_size(0), wordvec_dim(0), hidden_dim(0), start_token_index(0), end_token_index(0), unk_token_index(0) {
  }

  virtual ~ModelInfo() throw() {}

  int32_t window_size;
  int32_t wordvec_dim;
  int32_t hidden_dim;
  int32_t start_token_index;
  int32_t end_token_index;
  int32_t unk_token_index;
  std::vector<std::string>  vocab;

  _ModelInfo__isset __isset;

  void __set_window_size(const int32_t val) {
    window_size = val;
  }

  void __set_wordvec_dim(const int32_t val) {
    wordvec_dim = val;
  }

  void __set_hidden_dim(const int32_t val) {
    hidden_dim = val;
  }

  void __set_start_token_index(const int32_t val) {
    start_token_index = val;
  }

  void __set_end_token_index(const int32_t val) {
    end_token_index = val;
  }

  void __set_unk_token_index(const int32_t val) {
    unk_token_index = val;
  }

  void __set_vocab(const std::vector<std::string> & val) {
    vocab = val;
  }

  bool operator == (const ModelInfo & rhs) const
  {
    if (!(window_size == rhs.window_size))
      return false;
    if (!(wordvec_dim == rhs.wordvec_dim))
      return false;
    if (!(hidden_dim == rhs.hidden_dim))
      return false;
    if (!(start_token_index == rhs.start_token_index))
      return false;
    if (!(end_token_index == rhs.end_token_index))
      return false;
    if (!(unk_token_index == rhs.unk_token_index))
      return false;
    if (!(vocab == rhs.vocab))
      return false;
    return true;
  }
  bool operator != (const ModelInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ModelInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ModelInfo &a, ModelInfo &b);

typedef struct _Params__isset {
  _Params__isset() : wordvec_w(false), input_hidden_w(false), input_hidden_b(false), hidden_output_w(false), hidden_output_b(false) {}
  bool wordvec_w;
  bool input_hidden_w;
  bool input_hidden_b;
  bool hidden_output_w;
  bool hidden_output_b;
} _Params__isset;

class Params {
 public:

  static const char* ascii_fingerprint; // = "3EA3FAC2464C28F7A32E48AAB85D2BDB";
  static const uint8_t binary_fingerprint[16]; // = {0x3E,0xA3,0xFA,0xC2,0x46,0x4C,0x28,0xF7,0xA3,0x2E,0x48,0xAA,0xB8,0x5D,0x2B,0xDB};

  Params() {
  }

  virtual ~Params() throw() {}

  std::vector<std::vector<double> >  wordvec_w;
  std::vector<std::vector<double> >  input_hidden_w;
  std::vector<double>  input_hidden_b;
  std::vector<double>  hidden_output_w;
  std::vector<double>  hidden_output_b;

  _Params__isset __isset;

  void __set_wordvec_w(const std::vector<std::vector<double> > & val) {
    wordvec_w = val;
  }

  void __set_input_hidden_w(const std::vector<std::vector<double> > & val) {
    input_hidden_w = val;
  }

  void __set_input_hidden_b(const std::vector<double> & val) {
    input_hidden_b = val;
  }

  void __set_hidden_output_w(const std::vector<double> & val) {
    hidden_output_w = val;
  }

  void __set_hidden_output_b(const std::vector<double> & val) {
    hidden_output_b = val;
  }

  bool operator == (const Params & rhs) const
  {
    if (!(wordvec_w == rhs.wordvec_w))
      return false;
    if (!(input_hidden_w == rhs.input_hidden_w))
      return false;
    if (!(input_hidden_b == rhs.input_hidden_b))
      return false;
    if (!(hidden_output_w == rhs.hidden_output_w))
      return false;
    if (!(hidden_output_b == rhs.hidden_output_b))
      return false;
    return true;
  }
  bool operator != (const Params &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Params & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Params &a, Params &b);

typedef struct _ParamUpdate__isset {
  _ParamUpdate__isset() : wordvec_w(false), input_hidden_w(false), input_hidden_b(false), hidden_output_w(false), hidden_output_b(false) {}
  bool wordvec_w;
  bool input_hidden_w;
  bool input_hidden_b;
  bool hidden_output_w;
  bool hidden_output_b;
} _ParamUpdate__isset;

class ParamUpdate {
 public:

  static const char* ascii_fingerprint; // = "63313E5EA4BE3F473AF76769976DB887";
  static const uint8_t binary_fingerprint[16]; // = {0x63,0x31,0x3E,0x5E,0xA4,0xBE,0x3F,0x47,0x3A,0xF7,0x67,0x69,0x97,0x6D,0xB8,0x87};

  ParamUpdate() {
  }

  virtual ~ParamUpdate() throw() {}

  std::map<int32_t, std::vector<double> >  wordvec_w;
  std::vector<std::vector<double> >  input_hidden_w;
  std::vector<double>  input_hidden_b;
  std::vector<double>  hidden_output_w;
  std::vector<double>  hidden_output_b;

  _ParamUpdate__isset __isset;

  void __set_wordvec_w(const std::map<int32_t, std::vector<double> > & val) {
    wordvec_w = val;
  }

  void __set_input_hidden_w(const std::vector<std::vector<double> > & val) {
    input_hidden_w = val;
  }

  void __set_input_hidden_b(const std::vector<double> & val) {
    input_hidden_b = val;
  }

  void __set_hidden_output_w(const std::vector<double> & val) {
    hidden_output_w = val;
  }

  void __set_hidden_output_b(const std::vector<double> & val) {
    hidden_output_b = val;
  }

  bool operator == (const ParamUpdate & rhs) const
  {
    if (!(wordvec_w == rhs.wordvec_w))
      return false;
    if (!(input_hidden_w == rhs.input_hidden_w))
      return false;
    if (!(input_hidden_b == rhs.input_hidden_b))
      return false;
    if (!(hidden_output_w == rhs.hidden_output_w))
      return false;
    if (!(hidden_output_b == rhs.hidden_output_b))
      return false;
    return true;
  }
  bool operator != (const ParamUpdate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ParamUpdate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ParamUpdate &a, ParamUpdate &b);

typedef struct _AnnounceResponse__isset {
  _AnnounceResponse__isset() : model_info(false), params(false), shard_paths(false), learn_rate(false), batch_size(false) {}
  bool model_info;
  bool params;
  bool shard_paths;
  bool learn_rate;
  bool batch_size;
} _AnnounceResponse__isset;

class AnnounceResponse {
 public:

  static const char* ascii_fingerprint; // = "CF757616D00450E15C73B4E398548BE7";
  static const uint8_t binary_fingerprint[16]; // = {0xCF,0x75,0x76,0x16,0xD0,0x04,0x50,0xE1,0x5C,0x73,0xB4,0xE3,0x98,0x54,0x8B,0xE7};

  AnnounceResponse() : learn_rate(0), batch_size(0) {
  }

  virtual ~AnnounceResponse() throw() {}

  ModelInfo model_info;
  Params params;
  std::vector<std::string>  shard_paths;
  double learn_rate;
  int32_t batch_size;

  _AnnounceResponse__isset __isset;

  void __set_model_info(const ModelInfo& val) {
    model_info = val;
  }

  void __set_params(const Params& val) {
    params = val;
  }

  void __set_shard_paths(const std::vector<std::string> & val) {
    shard_paths = val;
  }

  void __set_learn_rate(const double val) {
    learn_rate = val;
  }

  void __set_batch_size(const int32_t val) {
    batch_size = val;
  }

  bool operator == (const AnnounceResponse & rhs) const
  {
    if (!(model_info == rhs.model_info))
      return false;
    if (!(params == rhs.params))
      return false;
    if (!(shard_paths == rhs.shard_paths))
      return false;
    if (!(learn_rate == rhs.learn_rate))
      return false;
    if (!(batch_size == rhs.batch_size))
      return false;
    return true;
  }
  bool operator != (const AnnounceResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AnnounceResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AnnounceResponse &a, AnnounceResponse &b);

typedef struct _HBResponse__isset {
  _HBResponse__isset() : completed_shards(false) {}
  bool completed_shards;
} _HBResponse__isset;

class HBResponse {
 public:

  static const char* ascii_fingerprint; // = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

  HBResponse() {
  }

  virtual ~HBResponse() throw() {}

  std::vector<std::string>  completed_shards;

  _HBResponse__isset __isset;

  void __set_completed_shards(const std::vector<std::string> & val) {
    completed_shards = val;
  }

  bool operator == (const HBResponse & rhs) const
  {
    if (!(completed_shards == rhs.completed_shards))
      return false;
    return true;
  }
  bool operator != (const HBResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HBResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(HBResponse &a, HBResponse &b);

typedef struct _StartRequest__isset {
  _StartRequest__isset() : shard_paths(false), learn_rate(false), batch_size(false) {}
  bool shard_paths;
  bool learn_rate;
  bool batch_size;
} _StartRequest__isset;

class StartRequest {
 public:

  static const char* ascii_fingerprint; // = "D5FBD733341E7B24E6886D2BF393E431";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0xFB,0xD7,0x33,0x34,0x1E,0x7B,0x24,0xE6,0x88,0x6D,0x2B,0xF3,0x93,0xE4,0x31};

  StartRequest() : learn_rate(0), batch_size(0) {
  }

  virtual ~StartRequest() throw() {}

  std::vector<std::string>  shard_paths;
  double learn_rate;
  int32_t batch_size;

  _StartRequest__isset __isset;

  void __set_shard_paths(const std::vector<std::string> & val) {
    shard_paths = val;
  }

  void __set_learn_rate(const double val) {
    learn_rate = val;
  }

  void __set_batch_size(const int32_t val) {
    batch_size = val;
  }

  bool operator == (const StartRequest & rhs) const
  {
    if (!(shard_paths == rhs.shard_paths))
      return false;
    if (!(learn_rate == rhs.learn_rate))
      return false;
    if (!(batch_size == rhs.batch_size))
      return false;
    return true;
  }
  bool operator != (const StartRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StartRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StartRequest &a, StartRequest &b);

} // namespace

#endif
