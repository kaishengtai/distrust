/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef distrust_TYPES_H
#define distrust_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace distrust {

class ModelInfo;

class Params;

class AnnounceResponse;

class HBResponse;

class StartRequest;

typedef struct _ModelInfo__isset {
  _ModelInfo__isset() : window_size(false), wordvec_dim(false), hidden_dim(false), start_token_index(false), end_token_index(false), unk_token_index(false), vocab(false) {}
  bool window_size :1;
  bool wordvec_dim :1;
  bool hidden_dim :1;
  bool start_token_index :1;
  bool end_token_index :1;
  bool unk_token_index :1;
  bool vocab :1;
} _ModelInfo__isset;

class ModelInfo {
 public:

  static const char* ascii_fingerprint; // = "DB2CF0470155E4641638FF4CB4C715EE";
  static const uint8_t binary_fingerprint[16]; // = {0xDB,0x2C,0xF0,0x47,0x01,0x55,0xE4,0x64,0x16,0x38,0xFF,0x4C,0xB4,0xC7,0x15,0xEE};

  ModelInfo(const ModelInfo&);
  ModelInfo& operator=(const ModelInfo&);
  ModelInfo() : window_size(0), wordvec_dim(0), hidden_dim(0), start_token_index(0), end_token_index(0), unk_token_index(0) {
  }

  virtual ~ModelInfo() throw();
  int32_t window_size;
  int32_t wordvec_dim;
  int32_t hidden_dim;
  int32_t start_token_index;
  int32_t end_token_index;
  int32_t unk_token_index;
  std::vector<std::string>  vocab;

  _ModelInfo__isset __isset;

  void __set_window_size(const int32_t val);

  void __set_wordvec_dim(const int32_t val);

  void __set_hidden_dim(const int32_t val);

  void __set_start_token_index(const int32_t val);

  void __set_end_token_index(const int32_t val);

  void __set_unk_token_index(const int32_t val);

  void __set_vocab(const std::vector<std::string> & val);

  bool operator == (const ModelInfo & rhs) const
  {
    if (!(window_size == rhs.window_size))
      return false;
    if (!(wordvec_dim == rhs.wordvec_dim))
      return false;
    if (!(hidden_dim == rhs.hidden_dim))
      return false;
    if (!(start_token_index == rhs.start_token_index))
      return false;
    if (!(end_token_index == rhs.end_token_index))
      return false;
    if (!(unk_token_index == rhs.unk_token_index))
      return false;
    if (!(vocab == rhs.vocab))
      return false;
    return true;
  }
  bool operator != (const ModelInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ModelInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ModelInfo& obj);
};

void swap(ModelInfo &a, ModelInfo &b);

typedef struct _Params__isset {
  _Params__isset() : wordvec_weights(false), input_hidden_weights(false), input_hidden_biases(false), hidden_output_weights(false), hidden_output_biases(false) {}
  bool wordvec_weights :1;
  bool input_hidden_weights :1;
  bool input_hidden_biases :1;
  bool hidden_output_weights :1;
  bool hidden_output_biases :1;
} _Params__isset;

class Params {
 public:

  static const char* ascii_fingerprint; // = "882E5A0F5FB0D66D6CADC597860F19AF";
  static const uint8_t binary_fingerprint[16]; // = {0x88,0x2E,0x5A,0x0F,0x5F,0xB0,0xD6,0x6D,0x6C,0xAD,0xC5,0x97,0x86,0x0F,0x19,0xAF};

  Params(const Params&);
  Params& operator=(const Params&);
  Params() {
  }

  virtual ~Params() throw();
  std::vector<double>  wordvec_weights;
  std::vector<double>  input_hidden_weights;
  std::vector<double>  input_hidden_biases;
  std::vector<double>  hidden_output_weights;
  std::vector<double>  hidden_output_biases;

  _Params__isset __isset;

  void __set_wordvec_weights(const std::vector<double> & val);

  void __set_input_hidden_weights(const std::vector<double> & val);

  void __set_input_hidden_biases(const std::vector<double> & val);

  void __set_hidden_output_weights(const std::vector<double> & val);

  void __set_hidden_output_biases(const std::vector<double> & val);

  bool operator == (const Params & rhs) const
  {
    if (!(wordvec_weights == rhs.wordvec_weights))
      return false;
    if (!(input_hidden_weights == rhs.input_hidden_weights))
      return false;
    if (!(input_hidden_biases == rhs.input_hidden_biases))
      return false;
    if (!(hidden_output_weights == rhs.hidden_output_weights))
      return false;
    if (!(hidden_output_biases == rhs.hidden_output_biases))
      return false;
    return true;
  }
  bool operator != (const Params &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Params & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Params& obj);
};

void swap(Params &a, Params &b);

typedef struct _AnnounceResponse__isset {
  _AnnounceResponse__isset() : model_info(false), params(false), shard_paths(false), learn_rate(false) {}
  bool model_info :1;
  bool params :1;
  bool shard_paths :1;
  bool learn_rate :1;
} _AnnounceResponse__isset;

class AnnounceResponse {
 public:

  static const char* ascii_fingerprint; // = "370814B177BFFA9DA1F1788F8C73699F";
  static const uint8_t binary_fingerprint[16]; // = {0x37,0x08,0x14,0xB1,0x77,0xBF,0xFA,0x9D,0xA1,0xF1,0x78,0x8F,0x8C,0x73,0x69,0x9F};

  AnnounceResponse(const AnnounceResponse&);
  AnnounceResponse& operator=(const AnnounceResponse&);
  AnnounceResponse() : learn_rate(0) {
  }

  virtual ~AnnounceResponse() throw();
  ModelInfo model_info;
  Params params;
  std::vector<std::string>  shard_paths;
  double learn_rate;

  _AnnounceResponse__isset __isset;

  void __set_model_info(const ModelInfo& val);

  void __set_params(const Params& val);

  void __set_shard_paths(const std::vector<std::string> & val);

  void __set_learn_rate(const double val);

  bool operator == (const AnnounceResponse & rhs) const
  {
    if (!(model_info == rhs.model_info))
      return false;
    if (!(params == rhs.params))
      return false;
    if (!(shard_paths == rhs.shard_paths))
      return false;
    if (!(learn_rate == rhs.learn_rate))
      return false;
    return true;
  }
  bool operator != (const AnnounceResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AnnounceResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const AnnounceResponse& obj);
};

void swap(AnnounceResponse &a, AnnounceResponse &b);

typedef struct _HBResponse__isset {
  _HBResponse__isset() : completed_shards(false) {}
  bool completed_shards :1;
} _HBResponse__isset;

class HBResponse {
 public:

  static const char* ascii_fingerprint; // = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

  HBResponse(const HBResponse&);
  HBResponse& operator=(const HBResponse&);
  HBResponse() {
  }

  virtual ~HBResponse() throw();
  std::vector<std::string>  completed_shards;

  _HBResponse__isset __isset;

  void __set_completed_shards(const std::vector<std::string> & val);

  bool operator == (const HBResponse & rhs) const
  {
    if (!(completed_shards == rhs.completed_shards))
      return false;
    return true;
  }
  bool operator != (const HBResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HBResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const HBResponse& obj);
};

void swap(HBResponse &a, HBResponse &b);

typedef struct _StartRequest__isset {
  _StartRequest__isset() : shard_paths(false), learn_rate(false) {}
  bool shard_paths :1;
  bool learn_rate :1;
} _StartRequest__isset;

class StartRequest {
 public:

  static const char* ascii_fingerprint; // = "F96E9B21D37ECC1E6B1D9CC351B177C9";
  static const uint8_t binary_fingerprint[16]; // = {0xF9,0x6E,0x9B,0x21,0xD3,0x7E,0xCC,0x1E,0x6B,0x1D,0x9C,0xC3,0x51,0xB1,0x77,0xC9};

  StartRequest(const StartRequest&);
  StartRequest& operator=(const StartRequest&);
  StartRequest() : learn_rate(0) {
  }

  virtual ~StartRequest() throw();
  std::vector<std::string>  shard_paths;
  double learn_rate;

  _StartRequest__isset __isset;

  void __set_shard_paths(const std::vector<std::string> & val);

  void __set_learn_rate(const double val);

  bool operator == (const StartRequest & rhs) const
  {
    if (!(shard_paths == rhs.shard_paths))
      return false;
    if (!(learn_rate == rhs.learn_rate))
      return false;
    return true;
  }
  bool operator != (const StartRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StartRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const StartRequest& obj);
};

void swap(StartRequest &a, StartRequest &b);

} // namespace

#endif
